# AI for cyber security 2022/23
# Authors:
# - Cirillo Benedetto 
# - Montervino Dario 
# - Salzano Simone
# - Tisi Andrea

import torch.nn as nn
import torch
import torch.optim as optim
from torchvision import  transforms
# from torchsummary import summary #network summary

# imported by us
from argparse import ArgumentParser
from model.MalConv import MalConv
from utils import cnn_training
from torch.utils.data import DataLoader

from utils.TarDataset import TarDataset



def main():
  #---------------------------------- DEFINITION OF THE CLASSES ----------------------------------------
  parser = ArgumentParser()
  parser.add_argument('--batch_size', help='The batch size', type=int, default=256)
  parser.add_argument('--model_save_path', help='Folder where the model will be saved', type=str, default=None)
  parser.add_argument('--n_epochs', help='Number of epochs in the training phase', type=int, default=50)
  parser.add_argument('--early_stopping', help='Max number of epochs without an improvement on the validation_accuracy', type=int, default=0)
  parser.add_argument('--file_dim', help='Max dim of the input file for the model (in MB)', type=int, default=2)
  parser.add_argument('--verbose', help='Show the progress during the training phase', type=int, default=1)
  parser.add_argument('--dataset_path', help='Dataset Tar Location (no GZ compression)', type=str, default=None)
  parser.add_argument('--model_eval_path', help='Folder where the model will be taken for evaulate it', type=str, default=None)
  args = parser.parse_args()
  print("\nModel paramteres:\n")
  print("Batch size: ",args.batch_size)
  print("Folder where the model will be saved: ",args.model_save_path)
  print("Folder where the model will be taken: ",args.model_eval_path)
  print("Number of epochs in the training phase: ",args.n_epochs)
  
  if args.file_dim==2:
    file_dim=2**21
    print("Model: MalConv (file dim of ",file_dim," byte)")
  else:
    file_dim=2**20
    print("Model: emberMalConv (file dim of ",file_dim," byte)")
  print("Verbose: ", args.verbose==1)
  print("\n")

  # Selecting the device 
  device=cnn_training.get_device()
  if args.verbose==1:
    print("Is the GPU aviable? ",torch.backends.mps.is_available() or torch.cuda.is_available())

  torch.manual_seed(666)
  
  
  if args.model_save_path is not None:

    #---------------------------------- PREPARATION OF THE DATASET ----------------------------------------
    file_list_train = cnn_training.get_file_list(args.dataset_path, 'train')
    dataset = TarDataset(path_tar=args.dataset_path,member_list=file_list_train,first_n_byte=file_dim, padding=True, transform=None)
    train_size=len(dataset)-round(len(dataset)/5)
    test_size=round(len(dataset)/5)
    print(train_size, test_size)
    train_set, val_set =  torch.utils.data.random_split(dataset, [train_size, test_size])
    train_loader = DataLoader(train_set, batch_size=args.batch_size, num_workers=1, shuffle=True)
    val_loader = DataLoader(val_set, batch_size=args.batch_size, num_workers=1, shuffle=True)
    dataloader={
      'train': train_loader,
      'validation': val_loader
    }

    #---------------------------------- PREPARATION OF THE MODEL ----------------------------------------
    model=MalConv(input_length=file_dim)
    criterion =nn.BCELoss()
    optimizer = optim.Adam(model.parameters())


    
    #---------------------------------- TRAINING PHASE ----------------------------------------
    cnn_training.train_model(model, criterion, optimizer, device, dataloader,args.n_epochs,  args.model_save_path, early_stopping=args.early_stopping )
    
    #---------------------------------- TEST PHASE ----------------------------------------
  elif args.model_eval_path is not None:
    file_list_test = cnn_training.get_file_list(args.dataset_path, 'test')
    train_set = TarDataset(path_tar=args.dataset_path,member_list=file_list_test,first_n_byte=file_dim, padding=True, transform=None)
    test_loader=DataLoader(train_set, batch_size=args.batch_size, num_workers=1, shuffle=True)
    print(f"Train Set Length:{len(train_set)}")
    model=torch.load(args.model_eval_path)
    criterion =nn.BCELoss()
    loss_list, acc_list = cnn_training.model_evaluate(model, test_loader, device, criterion, args.verbose)   #return acc and loss lists on loader
    test_acc = sum(acc_list)/float(len(acc_list))
    test_loss = sum(loss_list)/float(len(loss_list))

    print("The Malconv model has {:.3f} of accuracy and {:.3f} of loss on the test set".format(test_acc,test_loss))

    
  
