from argparse import ArgumentParser
import pickle
import tarfile
from secml_malware.attack.blackbox.c_wrapper_phi import CEnd2EndWrapperPhi
from secml_malware.attack.blackbox.ga.c_base_genetic_engine import CGeneticAlgorithm
from secml_malware.models.c_classifier_end2end_malware import CClassifierEnd2EndMalware
from secml_malware.attack.blackbox.c_gamma_sections_evasion import CGammaSectionsEvasionProblem
from secml.array import CArray
import magic
import numpy as np
import torch
import os
import torch.nn as nn
import torch.optim as optim
from secml_malware.models.malconv import MalConv
import time

X = []
y = []

parser = ArgumentParser()
parser.add_argument('--dataset_path', help='Path where malwares are stored', type=str, default=None)
parser.add_argument('--model_path', help='Path where the model is stored', type=str, default=None)
parser.add_argument('--benign_folder', help='Path where the benigns are stored',type=str, default=None)
parser.add_argument('--file_dim', help='Max dim of the input file for the model (in MB)', type=int, default=2)
parser.add_argument('--malware_list', help='List of Malwares to which the attack is applied',type=str, default=None)
parser.add_argument('--adv_folder', help='Path where the adversarial samples are stored', type=str, default=None)
args = parser.parse_args()

if args.file_dim==2:
    file_dim=2**21
else:
    file_dim=2**20

with open(args.malware_list,'rb') as handler: 
    malware_list = pickle.load(handler)


model = MalConv(max_input_size=file_dim)
# criterion = nn.BCELoss()
# model.load_state_dict(torch.load(args.model_path))
net = CClassifierEnd2EndMalware(model)
net.load_pretrained_model(path=args.model_path)
net = CEnd2EndWrapperPhi(net)

malware_folder = args.dataset_path

# List of malware samples to be obfuscated
for i, f in enumerate(malware_list):
    x = CArray(np.frombuffer(f, dtype=np.uint8)).atleast_2d()
    _, confidence = net.predict(x, True)

    X.append(x)
    conf = confidence[1][0].item()
    y.append([1 - conf, conf])
    break

# Creating the population
section_population, what_from_who = CGammaSectionsEvasionProblem\
    .create_section_population_from_folder(
        args.benign_folder,  # folder of sources to extract the sections
        how_many=40,  # number of sections to be extracted from all the files
        sections_to_extract=['.rdata', '.data'])  # sections to be extracted
print("Finish Population")
# Creating section injection attack
attack = CGammaSectionsEvasionProblem(
    section_population,  # section population
    net,  # model to be attacked
    population_size=30,  # population size at each round of the algorithm
    penalty_regularizer=1e-2,
    iterations=100,  # maximum iterations
    threshold=0.5,
    is_debug=True)
print("Finish Gamma Evasion Problem")

engine = CGeneticAlgorithm(attack)

# sample obfuscation
count = 0
for sample, label in zip(X, y):
    y_pred, adv_score, adv_ds, f_obj = engine.run(sample, CArray(label[1]))
    adv_x = adv_ds.X[0, :]
    engine.write_adv_to_file(adv_x, args.adv_folder+'/sample_{}'.format(count))
    count += 1

# Checking the effectiveness of the attack
tot_files = len(os.listdir(args.adv_folder))
print(tot_files)
print(os.listdir(args.adv_folder))
correct = 0
for i, f in enumerate(os.listdir(args.adv_folder)):
    path = args.adv_folder+'/'+f
    with open(path, "rb") as file_handle:
        code = file_handle.read()
    x = CArray(np.frombuffer(code, dtype=np.uint8)).atleast_2d()
    _, confidence = net.predict(x, True)
    
    print(confidence[0, 1].item())

    if confidence[0, 1].item() < 0.5:
        continue
    correct += 1

acc = round(100.0*correct/tot_files, 1)
print("GAMMA attack with Model Accuracy: {}% \n".format(acc))
